def initialize (col, fil, N, *tuplas) 	#N es el numero de elementos no nulos
										#tuplas trataremos los datos asi: (3,0,1),(1,2,4),(5,4,6)...(2,6,7),(2,8,6)
										# donde agrupamos de tres en tres,(v,i,j) v= valor, i=fila, j=columna
	@columnas = col
	@filas = fil
	@n_nonulo = N
	
	V = Array.new(N)
	I = Array.new(N)
	J = Array.new(N)
	
	ind = 0
	while (ind < (3*N))
		if (tuplas[ind] != 0)
			V[ind]=tuplas[ind]   #almacena el valor no nulo
		end
		if (tuplas[ind+1],tuplas[ind+2] <= @filas, @columnas) #comparamos que los valores sean posibles
			I[ind]=tuplas[ind+1] # posicion filas de dicho elemento
			J[ind]=tuplas[ind+2] # posicion columnas de dicho elemento
		end
		
		ind += 3	#vamos al siguiente trio v i j
	end
	
end

def +(object)

	if ((object.instance_of?(Matriz) == true) && (@filas == object.filas) && (@columnas == object.columnas))
	
		i=0
		m_res=Matriz.new(@filas,@columnas)
		while i<object.filas
		
			j=0
			while j<object.columnas
			
				ind = 0
				while ind<@N
				
					if(i,j == I[ind],J[ind])
						m_res[i,j]= object[i,j] + V[ind]
					else
						m_res[i,j]= object[i,j]
					end
				end
				j += 1
			end
			i += 1
		end
	end
##repasar implemeentacion#####
	if ((object.instance_of?(Matriz_dispersa) == true) && (@filas == object.filas) && (@columnas == object.columnas))
		m_res=M_sparce.new(@filas,@columnas)
		i=0
		while i<@n_nonulo
		
			j = 0
			while j<object.n_nonulo
				if (@I[i],@J[i]==object.I[j],object.J[j])
					m_res[]
					
			end
		end
	end
###############################
end
